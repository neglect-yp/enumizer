package main

import (
	"bytes"
	"context"
	"flag"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/go/packages"
)

var (
	path   = flag.String("path", "./internal/api/domain/model", "path to model package")
	output = flag.String("output", "./internal/api/domain/model/enumizer.gen.go", "path to output")
)

type Enum struct {
	Name     string
	Variants []string
}

func FindEnums(path string) ([]Enum, error) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedCompiledGoFiles |
			packages.NeedImports |
			packages.NeedTypes |
			packages.NeedTypesSizes |
			packages.NeedSyntax |
			packages.NeedTypesInfo,
	}, path)
	if err != nil {
		return nil, err
	}

	enumMap := make(map[string]Enum, 0)
	for _, pkg := range pkgs {
		for _, file := range pkg.Syntax {
			ast.Inspect(file, func(node ast.Node) bool {
				genDecl, ok := node.(*ast.GenDecl)
				if !ok {
					return true
				}

				if genDecl.Tok != token.CONST {
					return true
				}

				if genDecl.Doc == nil || !existsMarker(genDecl.Doc.List) {
					return true
				}

				var typeName string
				variants := make([]string, 0)
				for _, spec := range genDecl.Specs {
					spec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}

					for _, name := range spec.Names {
						t := types.TypeString(pkg.TypesInfo.ObjectOf(name).Type(), types.RelativeTo(pkg.Types))
						if typeName == "" {
							typeName = t
						}
						if t != typeName {
							logWithPos(pkg.Fset, genDecl.Pos(), "[Error] target const decl must include only one type. ignored")
							return false
						}
						variants = append(variants, name.String())
					}
				}

				enum, ok := enumMap[typeName]
				if ok {
					enumMap[typeName] = Enum{Name: typeName, Variants: append(enum.Variants, variants...)}
				} else {
					enumMap[typeName] = Enum{Name: typeName, Variants: variants}
				}

				return false
			})
		}
	}

	enumNames := make([]string, 0, len(enumMap))
	for name := range enumMap {
		enumNames = append(enumNames, name)
	}
	sort.Strings(enumNames)

	enums := make([]Enum, 0, len(enumMap))
	for _, name := range enumNames {
		enums = append(enums, enumMap[name])
	}

	return enums, nil
}

const marker = "enumizer:generate"

func existsMarker(comments []*ast.Comment) bool {
	for _, comment := range comments {
		commentBody := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
		if commentBody == marker {
			return true
		}
	}

	return false
}

func logWithPos(fset *token.FileSet, pos token.Pos, message string) {
	p := fset.Position(pos)
	log.Printf("%s:%d: %s", p.Filename, p.Line, message)
}

func GenerateEnumHelpers(enums []Enum) ([]byte, error) {
	tpl := template.Must(template.New("").Funcs(map[string]interface{}{
		"lowerCamel": strcase.ToLowerCamel,
	}).Parse(`
// Code generated by enumizer; DO NOT EDIT.
package model

import "fmt"

{{ range $i, $enum := . -}}
var {{ lowerCamel $enum.Name }}Set = map[{{ $enum.Name }}]struct{}{
{{ range $j, $variant := $enum.Variants -}}
{{ $variant }}: {},
{{ end -}}
}

func {{ $enum.Name }}List() []{{ $enum.Name }} {
	ret := make([]{{ $enum.Name }}, 0, len({{ lowerCamel $enum.Name }}Set))
	for v := range {{ lowerCamel $enum.Name }}Set {
		ret = append(ret, v)
	}
	return ret
}

func (m {{ $enum.Name }}) IsValid() bool {
	_, ok := {{ lowerCamel $enum.Name }}Set[m]
	return ok
}

func (m {{ $enum.Name }}) Validate() error {
	if !m.IsValid() {
		return fmt.Errorf("{{ $enum.Name }}(%v) is invalid", m)
	}
	return nil
}
{{ end -}}
`))

	buf := new(bytes.Buffer)
	if err := tpl.Execute(buf, enums); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func run(ctx context.Context) error {
	enums, err := FindEnums(*path)
	if err != nil {
		return err
	}

	src, err := GenerateEnumHelpers(enums)
	if err != nil {
		return err
	}

	return os.WriteFile(*output, src, 0644)
}

func main() {
	flag.Parse()

	if err := run(context.Background()); err != nil {
		log.Fatalf("%+v", err)
	}
}
